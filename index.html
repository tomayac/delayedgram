<!doctype html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="utf-8" />
    <title>Delayedgram</title>
    <link rel="icon" href="delayedgram.png" />
    <link
      rel="preload"
      href="invert.wasm"
      as="fetch"
      type="application/wasm"
      crossorigin="anonymous"
    />
    <link
      rel="preload"
      href="grayscale.wasm"
      as="fetch"
      type="application/wasm"
      crossorigin="anonymous"
    />
    <link rel="modulepreload" href="invert.js" />
    <link rel="modulepreload" href="grayscale.js" />
    <style>
      :root {
        font-family: system-ui, sans-serif;
        color-scheme: dark light;
      }
      .logo {
        vertical-align: text-bottom;
        display: inline;
        width: 40px;
        height: 40px;
      }
      .wrapper {
        display: flex;
        gap: 1rem;
        flex-direction: column;
        align-items: center;
      }
      #photos {
        margin-block-start: 1rem;
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
        justify-content: center;
      }
      video {
        display: block;
        width: 640px;
        height: 480px;
        background-color: darkgray;
      }
      button {
        display: block;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: red;
        border: solid 2px white;
        outline: solid 2px black;
        outline-offset: 5px;
        margin-block-start: -80px;
        cursor: pointer;
        z-index: 1;
      }
      button:hover {
        outline-offset: 4px;
      }
      button:active {
        outline-offset: 3px;
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <h1>
        <img class="logo" width="706" height="706" src="delayedgram.png" alt="" />
        Delayedgram
      </h1>
      <video id="video" autoplay playsinline></video>
      <button id="capture" aria-label="Capture photo"></button>
      <div id="photos"></div>
    </div>
    <canvas id="canvas" style="display: none"></canvas>

    <script type="module">
      import loadInvert from './invert.js';
      import loadGrayscale from './grayscale.js';

      const InvertFilter = await loadInvert();
      const GrayscaleFilter = await loadGrayscale();

      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const photos = document.getElementById('photos');
      const ctx = canvas.getContext('2d', {
        willReadFrequently: true,
      });
      const captureButton = document.getElementById('capture');
      let streaming = false;

      const applyFilters = async (ppmP3String) => {
        const file = new File([ppmP3String], 'input.ppm', {
          type: 'image/x-portable-bitmap',
        });
        const inputFileName = 'input.ppm';
        const buffer = await file.arrayBuffer();
        InvertFilter.FS.writeFile(inputFileName, new Uint8Array(buffer));
        GrayscaleFilter.FS.writeFile(inputFileName, new Uint8Array(buffer));
        const outputFileName = `${Math.random().toString().substr(2)}.ppm`;
        InvertFilter.callMain([inputFileName, `invert-${outputFileName}`]);
        GrayscaleFilter.callMain([inputFileName, `grayscale-${outputFileName}`]);
        ['invert-', 'grayscale-'].forEach(async (filter) => {
          const output = (
            filter === 'invert-' ? InvertFilter : GrayscaleFilter
          ).FS.readFile(`${filter}${outputFileName}`, { encoding: 'binary' });
          const file = new File([output], outputFileName, {
            type: 'image/x-portable-bitmap',
          });
          drawPPMP3Image(await file.text());
        });
      };

      async function drawPPMP3Image(ppmP3String) {
        const lines = ppmP3String.split('\n');
        const dataLines = lines.filter(
          (line) => line[0] !== '#' && line.trim() !== '',
        );
        const width = parseInt(dataLines[1].split(' ')[0], 10);
        const height = parseInt(dataLines[1].split(' ')[1], 10);
        const pixels = dataLines
          .splice(3)
          .join('\n')
          .split(/\s+/g)
          .map((pixel) => parseInt(pixel, 10));
        const imageData = new ImageData(width, height);
        for (let i = 0, j = 0; i < pixels.length; i += 3) {
          imageData.data[j + 0] = pixels[i + 0]; // Red
          imageData.data[j + 1] = pixels[i + 1]; // Green
          imageData.data[j + 2] = pixels[i + 2]; // Blue
          imageData.data[j + 3] = 255; // Alpha
          j += 4;
        }
        const bitmap = await createImageBitmap(imageData);
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(bitmap, 0, 0);
        photos.append(canvas);
      }

      async function setupCamera() {
        return new Promise(async (resolve, reject) => {
          try {
            const constraints = {
              video: { facingMode: 'user' },
            };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.addEventListener('canplay', () => {
              if (!streaming) {
                const height = video.videoHeight;
                const width = video.videoWidth;
                video.width = width;
                video.height = height;
                canvas.width = width;
                canvas.height = height;
                streaming = true;
              }
              resolve();
            });
            video.srcObject = stream;
          } catch (err) {
            reject(err);
          }
        });
      }

      captureButton.addEventListener('click', async () => {
        if (!video.srcObject) {
          try {
            await setupCamera();
            return;
          } catch (err) {
            console.error('Error accessing camera:', err);
            alert(`Error accessing camera: ${err}`);
            return;
          }
        }
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const ppmData = `P3\n${canvas.width} ${canvas.height}\n255\n`;
        const ppmBody = Array.from(imageData.data).reduce((acc, val, index) => {
          // Skip the alpha channel.
          if ((index + 1) % 4 !== 0) {
            acc += `${val} `;
          }
          return acc;
        }, '');

        const ppmP3String = ppmData + ppmBody;
        applyFilters(ppmP3String);
      });
    </script>
  </body>
</html>
